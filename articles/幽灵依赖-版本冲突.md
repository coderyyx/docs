# 解析 npm 和 yarn 中的“幽灵依赖” 和 “版本冲突”

### ​**什么是幽灵依赖？**

幽灵依赖是指项目中未在 `package.json` 中显式声明的依赖，却因为依赖的依赖被提升到顶层 `node_modules` 中，导致项目代码可以直接引用这些未声明的包。例如：

- 项目安装了 `A`，而 `A` 依赖 `B@1.0.0`。
- 由于 `npm` 或 `yarn` 的扁平化结构，`B@1.0.0` 被提升到顶层 `node_modules`。
- 项目代码可以直接引用 `B`，即使 `package.json` 中并未声明 `B`。

这种未声明的依赖会带来以下问题：

- ​**版本失控**：当 `A` 升级到依赖 `B@2.0.0` 时，直接引用 `B` 的代码会突然崩溃。
- ​**依赖黑洞**：新成员克隆项目后运行 `npm install`，可能会发现缺失 `B` 模块。
- ​**安全风险**：未经验证的间接依赖可能携带安全漏洞。

### ​pnpm 如何解决幽灵依赖？

`pnpm` 通过以下机制彻底杜绝了幽灵依赖问题：

#### （1）​**符号链接与硬链接**

- `pnpm` 使用符号链接（Symbolic Link）和硬链接（Hard Link）来管理依赖。
- 所有依赖包都存储在全局的 `.pnpm-store` 中，项目中的 `node_modules` 仅包含符号链接，指向 `.pnpm` 目录中的硬链接。
- 每个包只能访问其 `package.json` 中显式声明的依赖，未声明的依赖无法被访问。

#### （2）​**严格的依赖隔离**

- `pnpm` 的 `node_modules` 结构是严格隔离的，每个包的依赖都位于 `.pnpm/<package>@<version>/node_modules` 中。
- 这种设计确保每个包只能访问其声明的依赖，避免了未声明依赖的意外使用。

#### （3）​**全局存储与复用**

- `pnpm` 使用全局存储（`~/.pnpm-store`）来存储所有依赖包，并通过硬链接复用相同的包。
- 这种机制不仅节省磁盘空间，还确保了依赖的唯一性和一致性。

### ​**什么是版本冲突**

- 在项目中，多个依赖包可能依赖于同一个库的不同版本。例如，`A` 依赖 `B@1.0.0`，而 `C` 依赖 `B@2.0.0`。
- 传统的包管理工具（如 `npm` 和 `yarn`）在扁平化结构中，只能将其中一个版本的 `B` 提升到顶层 `node_modules`，另一个版本则嵌套在依赖包的 `node_modules` 中。
- 这种处理方式可能导致以下问题：
  - ​**运行时错误**：如果 `A` 和 `C` 都直接引用 `B`，但 `B` 的版本不兼容，可能会导致程序崩溃或行为异常。
  - ​**依赖不确定性**：提升哪个版本的 `B` 取决于依赖在 `package.json` 中的顺序，这种不确定性增加了调试和维护的难度。

#### npm 的依赖处理机制

- 嵌套依赖结构：
  npm 会在 `node_modules` 目录中为每个包创建自己的依赖树
  例如，`A` 会有自己的 `node_modules/B@1.0.0`，而 `C` 会有自己的 `node_modules/B@2.0.0`
  这样，`A` 和 `C` 可以各自使用它们所需的 `B` 版本，而不会相互干扰

- 依赖提升（Hoisting）：
  从 npm v3 开始，npm 引入了依赖提升机制，尝试将依赖"提升"到顶层 `node_modules` 目录
  如果多个包依赖相同版本的库，那么这个库只会安装一次在顶层
  但当存在版本冲突时，npm 会将一个版本放在顶层，其他版本放在各自依赖包的 `node_modules` 目录中

### ​pnpm 如何解决版本冲突？

`pnpm` 通过以下机制有效解决了版本冲突问题：

#### （1）​**严格的依赖隔离**

- `pnpm` 将每个依赖包及其依赖项严格隔离在 `.pnpm/<package>@<version>/node_modules` 目录中。
- 例如，`A` 依赖的 `B@1.0.0` 和 `C` 依赖的 `B@2.0.0` 分别存储在不同的路径中，互不干扰。
- 这种设计确保每个包只能访问其声明的依赖版本，避免了版本冲突。

#### （2）​**符号链接与硬链接**

- `pnpm` 使用符号链接将项目的直接依赖链接到 `.pnpm` 目录中的对应包。
- 通过硬链接复用全局存储中的依赖包，既节省磁盘空间，又确保依赖的唯一性。
- 例如，`A` 和 `C` 分别通过符号链接访问 `.pnpm/B@1.0.0` 和 `.pnpm/B@2.0.0`，避免了版本冲突。

#### （3）​**全局存储与复用**

- `pnpm` 使用全局存储（`~/.pnpm-store`）来存储所有依赖包，并通过硬链接复用相同的包。
- 这种机制不仅节省磁盘空间，还确保了依赖版本的一致性。

### **与传统工具的比较**

- ​`npm`、`yarn` 在扁平化结构中，只能提升一个版本的依赖，导致版本冲突和依赖不确定性。
- ​`pnpm` 通过严格的依赖隔离和符号链接，确保每个包都能访问其所需的依赖版本，彻底解决了版本冲突问题。

### ​**总结**

`pnpm` 通过符号链接、硬链接和全局存储机制，从根本上解决了幽灵依赖和版本冲突问题，确保了依赖管理的严格性和安全性。这种设计不仅避免了未声明依赖的意外使用，还显著提升了安装速度和磁盘空间利用率。

### 参考文章

- 1
- 2
